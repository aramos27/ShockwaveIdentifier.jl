var documenterSearchIndex = {"docs":
[{"location":"#ShockwaveIdentifier.jl-Documentation","page":"Home","title":"ShockwaveIdentifier.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Package ShockwaveIdentifier.jl enables the user to identify the position of shock waves from a grid, including the ability to: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interpret a grid of Nu x Nx grid data\nInterpret a grid of Nu x Nx x nY grid data\nFinding the Normal vectors of the shockwaves at their respective shock points.","category":"page"},{"location":"#Installation:","page":"Home","title":"Installation:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg Pkg.add(PackageSpec(url=\"https://github.com/aramos27/ShockwaveIdentifier.jl\"))","category":"page"},{"location":"#Example-usage:","page":"Home","title":"Example usage:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For example usage please refer to the demo files inside the scripts directory. ","category":"page"},{"location":"#Main-Functions:","page":"Home","title":"Main Functions:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"load_data\nfindShock1D\nfindAllShocks1D\nfindShock2D\nfindAllShocks2D\nnormalVectors\nplotframe1D\ngenerate_shock_plots1D\ngenerate_shock_plots2D\nplotframe2D","category":"page"},{"location":"#ShockwaveIdentifier.load_data","page":"Home","title":"ShockwaveIdentifier.load_data","text":"load_data(filename; T=Float64)\n\nLoad an array-based or cell-based simulation from filename. Supports .tape and .celltape files.\n\nArguments\n\nfilename: The path to the file to load (.tape or .celltape).\nT: (Optional) The data type to use for the simulation, default is Float64.\n\nReturns\n\nAn EulerSim or CellBasedEulerSim object based on the file type.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.findShock1D","page":"Home","title":"ShockwaveIdentifier.findShock1D","text":"findShock1D(frame, data::EulerSim{1, 3, T}; threshold=eps_1d) where {T}\n\nOur developed approach to detect shock wave points in 1D, based on a simple approach with a gradient threshold. The gradient threshold is the maximum gradient value multiplied by a constant threshold (default 0.5), which manages to detect all shocks in the test cases that we have received and to ignore high gradients caused by expansion waves, which can be visualized through the debug flag of generateshockplots1D. We compare the weighted density gradient (density gradient multiplied by velocity) and velocity gradient. Both need to be above the threshold to suffice our shock condition. \n\nInput arguments: \t- frame: the frame-th step that of the simulation object that shall be processed.     - data: EulerSim{1, 3, T} object generated by Euler2D. \t- threshold: (optional, default 0.5) factor of the maximum gradient     Shall return a list of indices where shockpoints are assumed.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.findAllShocks1D","page":"Home","title":"ShockwaveIdentifier.findAllShocks1D","text":"findAllShocks1D(data::EulerSim{1, 3, T}, threshold=eps_1d) where {T}\n\nThis function iterates over all frames in the given data and finds shock points for each frame of the simulation object data::EulerSim{1, 3, T} using the findShock1D function.\n\nInput arguments:\n\ndata: An EulerSim{1, 3, T} object generated by Euler2D.\nthreshold: (optional, default eps_1d) Factor of the maximum gradient.\n\nOutput:\n\nReturns a list of lists, where each sublist contains the indices of shock points  detected in each corresponding frame of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.findShock2D","page":"Home","title":"ShockwaveIdentifier.findShock2D","text":"Finds all shockpoints from the dataset data at the frame-th timestep and returns a list of their coordinates. Takes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.\nthreshold: threshold of eps1 variable in blank\nlevel: \n1 : usual method according to the paper mentioned above (finding extremal points of δ1ρ).\n2 : applies further nearest-neighbour edge detection with a less harsh condition (blanking threshold lowered), which slows down the function a bit.\n⋝ 4 : does NOT add removal  removal of lonely points (presumably noise)\n⋝ 5 : does NOT add removal of points near nothing values (obstacles)\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.findAllShocks2D","page":"Home","title":"ShockwaveIdentifier.findAllShocks2D","text":"findAllShocks2D takes as inputs:\n\ndata::EulerSim{2, 4, T} object generated by Euler2D.\n\nFor all frames it detects the shock points.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.normalVectors","page":"Home","title":"ShockwaveIdentifier.normalVectors","text":"normalVectors takes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.\nshocklist: List (or vector) of 2D points where a shock is detected.\n\nFor all points in the shocklist, normalVectors detects the direction of the shock by the pressure gradient's direction, and returns a vector of 2D directions,\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.plotframe1D","page":"Home","title":"ShockwaveIdentifier.plotframe1D","text":"plotframe1D(frame, data::EulerSim{1, 3, T}) where {T}\n\nPlots physical property data of the 1D case, such as velocity, density,  and pressure, without shockwave detection.\n\nArguments\n\nframe: The frame-th step of the simulation object to process.\ndata: An EulerSim{1, 3, T} object generated by Euler2D.\n\nReturns\n\nA plot visualizing the physical properties at the specified frame.\n\n\n\n\n\nplotframe1D(frame, data::EulerSim{1, 3, T}, shockwave_algorithm; save = false, debug = false, threshold = eps_1d) where {T}\n\nPlots the frame with shockwave detection using velocity data for improved accuracy.\n\nArguments\n\nframe: The frame-th step of the simulation object to process.\ndata: An EulerSim{1, 3, T} object generated by Euler2D.\nshockwave_algorithm: Function to determine shocks, taking frame and data as input.\nsave: A boolean flag indicating whether to save the figures directly.\ndebug: A boolean flag indicating whether to plot all graphs or only density and gradient plots.\nthreshold: A value passed to the shockwave_algorithm as an argument.\n\nReturns\n\nA plot visualizing the physical properties with shockwave information.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.generate_shock_plots1D","page":"Home","title":"ShockwaveIdentifier.generate_shock_plots1D","text":"generate_shock_plots1D(data::EulerSim{1, 3, T}; save_dir::String = \"frames\", shockwave_algorithm = findShock1D, html = false, threshold = eps_1d) where {T}\n\nDriver function that generates and saves plots of shock wave points for the 1D simulation.\n\nArguments\n\ndata: An EulerSim{1, 3, T} object representing the simulation data.\nsave_dir: The directory where generated figures will be stored.\nshockwave_algorithm: Function that detects shock points.\nhtml: A flag indicating whether to generate HTML output (not implemented).\nthreshold: Value passed to the shockwave detection algorithm.\n\nReturns\n\nNone (saves the generated plots as images).\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.generate_shock_plots2D","page":"Home","title":"ShockwaveIdentifier.generate_shock_plots2D","text":"generate_shock_plots2D(data::Union{EulerSim{2,4,T}, CellBasedEulerSim{T}}; save_dir::String=\"frames\", shockwave_algorithm=findShock2D, compute_data_func=compute_density_data, html=false, vectors=false, threshold=0.133, level=1) where {T}\n\nGenerates and saves plots of shock wave points for the 2D simulation.\n\nArguments\n\ndata: An EulerSim{2, 4, T} or CellBasedEulerSim{T} object representing the simulation data.\nsave_dir: The directory where generated figures will be stored.\nshockwave_algorithm: Function that detects shock points.\ncompute_data_func: Function to compute the data to visualize.\nhtml: A flag indicating whether to generate HTML output (not implemented).\nvectors: A boolean flag indicating whether to plot normal direction vectors at shock points.\nthreshold: Value passed to the shockwave detection algorithm.\nlevel: Level of detection for shocks.\n\nReturns\n\nNone (saves the generated plots as images).\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.plotframe2D","page":"Home","title":"ShockwaveIdentifier.plotframe2D","text":"plotframe2D(frame, data::EulerSim{2, 4, T}, compute_data_function) where {T}\n\nPlots a 2D frame of a physical quantity (e.g., pressure) from the simulation data.\n\nArguments\n\nframe: The frame-th step of the simulation object to process.\ndata: An EulerSim{2, 4, T} object representing the simulation data.\ncompute_data_function: Function to compute data to plot.\n\nReturns\n\nA plot visualizing the 2D physical properties at the specified frame.\n\n\n\n\n\nplotframe2D(frame, data::Union{EulerSim{2,4,T}, CellBasedEulerSim{T}}, compute_data_function, shockwave_algorithm; shockline=false, vectors=false, threshold=eps1_euler, level=1) where {T}\n\nPlots a 2D frame of the specified physical quantity (e.g., density) while incorporating shock points and, optionally, the normal vectors of the shocks.\n\nArguments\n\nframe: The frame-th step of the simulation object to process.\ndata: An EulerSim{2, 4, T} or CellBasedEulerSim{T} object representing the simulation data.\ncompute_data_function: Function used to compute the data to plot (e.g., density).\nshockwave_algorithm: Function that detects shock points.\nshockline: A boolean flag indicating whether to plot the shockwave line.\nvectors: A boolean flag indicating whether to plot normal direction vectors at shock points.\nthreshold: Value used in the shock detection algorithm.\nlevel: Level of detection for shocks.\n1: Coarse detection.\n2: Improved detection (uses findShock2D).\n\nReturns\n\nA plot object visualizing the specified 2D physical properties, including shock points and normal vectors if specified.\n\n\n\n\n\n","category":"function"},{"location":"#Additional-functions-found-in:","page":"Home","title":"Additional functions found in:","text":"","category":"section"},{"location":"#data_utils.jl:","page":"Home","title":"data_utils.jl:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ShockwaveIdentifier.compute_pressure_data\nShockwaveIdentifier.compute_velocity_data\nShockwaveIdentifier.compute_density_data\nShockwaveIdentifier.normalized_velocity\nShockwaveIdentifier.compute_velocity_magnitude_data\nShockwaveIdentifier.divide_matrices","category":"page"},{"location":"#ShockwaveIdentifier.compute_pressure_data","page":"Home","title":"ShockwaveIdentifier.compute_pressure_data","text":"compute_pressure_data(frame, data::EulerSim{2,4,T}) where {T}\n\nReturns a matrix of pressure data with units for a given array-based simulation.\n\nArguments\n\nframe: The frame number to extract the pressure data from.\ndata: An array-based simulation (EulerSim{2,4,T}).\n\nReturns\n\nA matrix containing the pressure values with appropriate units.\n\n\n\n\n\ncompute_pressure_data(frame, data::CellBasedEulerSim)\n\nReturns a matrix of pressure data with units for a given cell-based simulation.\n\nArguments\n\nframe: The frame number to extract the pressure data from.\ndata: A cell-based simulation (CellBasedEulerSim).\n\nReturns\n\nA matrix containing the pressure values with units stripped.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.compute_velocity_data","page":"Home","title":"ShockwaveIdentifier.compute_velocity_data","text":"compute_velocity_data(frame, data::EulerSim{2,4,T}) where {T}\n\nReturns a matrix of velocity data with units for a given array-based simulation.\n\nArguments\n\nframe: The frame number to extract the velocity data from.\ndata: An array-based simulation (EulerSim{2,4,T}).\n\nReturns\n\nA matrix containing the velocity values.\n\n\n\n\n\ncompute_velocity_data(frame, data::CellBasedEulerSim{T}) where {T}\n\nReturns a matrix of velocity data with units for a given cell-based simulation.\n\nArguments\n\nframe: The frame number to extract the velocity data from.\ndata: A cell-based simulation (CellBasedEulerSim{T}).\n\nReturns\n\nA matrix containing velocity vectors (as static vectors).\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.compute_density_data","page":"Home","title":"ShockwaveIdentifier.compute_density_data","text":"compute_density_data(frame, data::EulerSim{2,4,T}) where {T}\n\nReturns a matrix of density data with units for a given array-based simulation.\n\nArguments\n\nframe: The frame number to extract the density data from.\ndata: An array-based simulation (EulerSim{2,4,T}).\n\nReturns\n\nA matrix containing the density values.\n\n\n\n\n\ncompute_density_data(frame, data::CellBasedEulerSim)\n\nReturns a matrix of density data with units for a given cell-based simulation.\n\nArguments\n\nframe: The frame number to extract the density data from.\ndata: A cell-based simulation (CellBasedEulerSim).\n\nReturns\n\nA matrix containing the density values with units stripped.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.normalized_velocity","page":"Home","title":"ShockwaveIdentifier.normalized_velocity","text":"normalized_velocity(frame, data::Union{EulerSim{2,4,T}, CellBasedEulerSim{T}}) where {T}\n\nReturns a matrix of normalized velocity vectors for both array-based and cell-based simulations.\n\nArguments\n\nframe: The frame number to extract the velocity data from.\ndata: A simulation (EulerSim{2,4,T} or CellBasedEulerSim{T}).\n\nReturns\n\nA matrix of normalized velocity vectors.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.compute_velocity_magnitude_data","page":"Home","title":"ShockwaveIdentifier.compute_velocity_magnitude_data","text":"compute_velocity_magnitude_data(frame, data::Union{EulerSim{2,4,T}, CellBasedEulerSim{T}}) where {T}\n\nReturns a matrix of velocity magnitudes for both array-based and cell-based simulations.\n\nArguments\n\nframe: The frame number to extract the velocity data from.\ndata: A simulation (EulerSim{2,4,T} or CellBasedEulerSim{T}).\n\nReturns\n\nA matrix of velocity magnitudes.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.divide_matrices","page":"Home","title":"ShockwaveIdentifier.divide_matrices","text":"divide_matrices(matrix1, matrix2)\n\nGiven a matrix matrix1 of vectors [x, y] and a matrix matrix2 of scalar values, return the result of matrix1 / matrix2 element-wise.\n\nArguments\n\nmatrix1: A matrix with vector elements (e.g., SVector).\nmatrix2: A matrix with scalar elements.\n\nReturns\n\nA new matrix where each vector in matrix1 is divided by the corresponding scalar in matrix2.\n\n\n\n\n\n","category":"function"},{"location":"#plotting.jl:","page":"Home","title":"plotting.jl:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ShockwaveIdentifier.plot_bounds\nShockwaveIdentifier.plot_1d_heatmap\nShockwaveIdentifier.generateShock","category":"page"},{"location":"#ShockwaveIdentifier.plot_bounds","page":"Home","title":"ShockwaveIdentifier.plot_bounds","text":"plot_bounds(sim::EulerSim{N,NAXES,T}) where {N,NAXES,T}\n\nReturns plot boundaries of the simulation object sim for the 1D case. \n\nArguments\n\nsim: An EulerSim object representing the simulation data.\n\nReturns\n\nA tuple of the adjusted plot boundaries for each physical property in the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.plot_1d_heatmap","page":"Home","title":"ShockwaveIdentifier.plot_1d_heatmap","text":"plot_1d_heatmap(magnitude, filename::String)\n\nPlots a heatmap for a 1D scalar quantity (e.g., δ₁ρ and δ₂ρ).\n\nArguments\n\nmagnitude: The data to be visualized in a heatmap.\nfilename: The name of the file to save the heatmap plot.\n\nReturns\n\nNone (saves the generated heatmap as an image).\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.generateShock","page":"Home","title":"ShockwaveIdentifier.generateShock","text":"General-case wrapper discriminating 1D and 2D\n\n\n\n\n\n","category":"function"},{"location":"#findShock2D.jl","page":"Home","title":"findShock2D.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ShockwaveIdentifier.gradient_2d\nShockwaveIdentifier.delta_1p\nShockwaveIdentifier.find_zeros!\nShockwaveIdentifier.delta_2p\nShockwaveIdentifier.blank\nShockwaveIdentifier.find_neighbors\nShockwaveIdentifier.update_shocklist_refined\nShockwaveIdentifier.remove_lonely_points!\n","category":"page"},{"location":"#ShockwaveIdentifier.gradient_2d","page":"Home","title":"ShockwaveIdentifier.gradient_2d","text":"gradient_2d(data_no_units, hx, hy)\n\nComputes a matrix containing the gradient vector (∂ρ/∂x, ∂ρ/∂y) at each point, given the grid sizes hx and hy. \n\nArguments:\n\ndata_no_units: A 2D matrix representing scalar field values.\nhx: Grid size in the x-direction.\nhy: Grid size in the y-direction.\n\nReturns:\n\nA 2D matrix where each element is a 2-element static vector representing the gradient at each point.\n\n\n\n\n\ngradient_2d(frame, data, compute_data_function)\n\ntakes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.\ncomputedatafunction: function that computes some value such as pressure and returns a matrix of physical properties over a discretized field, optimally. E.g. computepressuredata\n\nCalls gradient2d(datano_units, hx, hy) after formatting data accordingly.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.delta_1p","page":"Home","title":"ShockwaveIdentifier.delta_1p","text":"delta_1p(frame, data)\n\ntakes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.   Calculate the piecewise dot-product of the normalized velocity and the gradient of the density data. According to the paper \"Accurate detection of shock waves and shock interactions in two-dimensional shock-capturing solutions.pdf\"\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.find_zeros!","page":"Home","title":"ShockwaveIdentifier.find_zeros!","text":"Serves the purpose of finding zeros in discretized data discret (Matrix) such as d1p and d2p through sign changes.  Wherever a sign change occurs, the values are replaced with 0.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.delta_2p","page":"Home","title":"ShockwaveIdentifier.delta_2p","text":"takes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.\n\nTurns 0 for shocks. Presumably, when the density gradient is also not zero.\n\nCalculate the piecewise dot-product of the normalized velocity and the gradient of the density data. According to the paper \"Accurate detection of shock waves and shock interactions in two-dimensional shock-capturing solutions.pdf\"\n\n\n\n\n\ntakes as inputs:\n\nframe: the frame-th step that of the simulation object that shall be processed.\ndata: EulerSim{2, 4, T} object generated by Euler2D.\nd1p: Matrix from precomputed d1p value (function delta_1p)\n\nFaster version when d1p is precomputed, taking d1p already into account.  optional argument d1p shall be a Matrix{T}\n\nTurns 0 for shocks. Presumably, when the density gradient is also not zero.\n\nCalculate the piecewise dot-product of the normalized velocity and the gradient of the density data. According to the paper \"Accurate detection of shock waves and shock interactions in two-dimensional shock-capturing solutions.pdf\"\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.blank","page":"Home","title":"ShockwaveIdentifier.blank","text":"blank() operates on a frame's precomputed data, taking the input arguments: d1p: Matrix of 2D-Values of d1p, computed with the equation used for function delta1p. Basically first gradient of density multiplied by normalized velocity. d2p: Matrix of 2D-Values of d2p, computed with the equation used for function delta2p. Basically gradient of d1p wrt. to space  multiplied by normalized velocity.\n\nBlanking part: Wherever d2p == 0 and d1p != 0, shocks shall be identified.\n\nNeeds d1p and d2p as arguments and finds the nul-points of d2p as possible extremals of d1p, and thus shockwaves. To eliminate the rest, only candidates with a d1p value above a certain threshold remain considered.\n\nTODO : Find eps1, eps2 so that it works. Possible, eps1 will have to depend on the intensity of shockwave. eps2 is set to take into account floating point arithmetic errors.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.find_neighbors","page":"Home","title":"ShockwaveIdentifier.find_neighbors","text":"Finds all neighboring points within a given radius from a point p on a grid.\n\nArguments:\n\np: A 2D point (centre)\nr: The radius within which neighbors should be found.\n\nReturns:\n\nA list of all neighbors of point p that are within distance r.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.update_shocklist_refined","page":"Home","title":"ShockwaveIdentifier.update_shocklist_refined","text":"Updates the shocklist by adding neighboring points from shocklist_relaxed close to points in shocklist.\n\nArguments:\n\nshocklist: The current list of shock points.\nshocklist_relaxed: Points that meet relaxed criteria for potential shocks.\nradius: The radius within which neighbors should be checked. 2 by default.\n\nReturns:\n\nModifies shocklist in place, adding neighboring points that satisfy the gradient conditions.\n\n\n\n\n\n","category":"function"},{"location":"#ShockwaveIdentifier.remove_lonely_points!","page":"Home","title":"ShockwaveIdentifier.remove_lonely_points!","text":"delete unnecessary shockpoints (false positives)     #standalone shock points: unlikely to happen\n\n    In an area around each point of the shocklist, the amount of fellow shock points is evaluated.\n    If it is under a certain threshold, we remove the shockpoint from the list as an allegedly lone shock point, which shall not exist. \n    (Or, must be sacrificed, in order to eliminate noise from the solver.)\n\n\n\n\n\n","category":"function"}]
}
